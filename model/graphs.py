import networkx as nx
import random
import numpy as np
from itertools import permutations, chain, combinations
def sequence_generator(maps,edges):
	"""
	Calls the function to generate a sequence.

	Parameters
	----------
	maps : dict
		key: node [int]
		value: state [float]
	edges : list
		A list of tuples where each tuple represents an edge connection between two nodes, e.g., (2,10)

	Returns
	-------
	[str]
		A binary string generated by the combination of nodes
	"""
	sequence = nx.DiGraph() #creates an empty DiGraph 
	for node in maps: #for each node in maps
		sequence.add_node(node,state=maps[node]) #add the nodes and state of the node 
	dic_state =  nx.get_node_attributes(sequence,'state')
	for ed1,ed2 in edges: #for each edge pair in the list edges
		weighting = (dic_state[ed1] + dic_state[ed2]) / 2 #get float value of the two edges
		if weighting == 0.5:
			rounded = random.choice([0,1])
		else:
			rounded = int(round(weighting))
		sequence.add_edge(ed1,ed2, weight = rounded) #assign rounded weight to as a value for the edge connection between two nodes
	weights = nx.get_edge_attributes(sequence,'weight')
	weight_sequence = sorted(weights) #orders weights by tuple values (lowest first)
	seq = [weights[i] for i in weight_sequence] 
	return ''.join(str(i) for i in seq) #returns string 

def node_generator(mapping):
	"""
	Calls the function to generate a sequence.

	Parameters
	----------
	maps : dict
		key: node [int]
		value: state [float]
	edges : list
		A list of tuples where each tuple represents an edge connection between two nodes, e.g., (2,10)

	Returns
	-------
	[str]
		A binary string generated by the combination of nodes
	"""
	state = np.linspace(0,1,11)
	if mapping == {}:
		nodes = [str(i) for i in range(0,5)]
		maps = {key:random.choice(state) for key in nodes}
	if mapping != {}:
		for i in mapping:
			if mapping[i] == []:
				mapping.update({i:random.choice(state)})
				maps = mapping
	return maps

def deletion(nodes,links):
	linkage = links
	if len(linkage) > 2:
		link_choice = random.choice(linkage)
		linkage.remove(link_choice)
	return linkage	

def invention(all_nodes,ag_nodes,ag_links):
	node_mappings = dict(all_nodes)
	nodes = [i for i in node_mappings]
	nodes.append(str(len(nodes)))
	selection = random.choice(nodes)
	agent_nodes = [i[0] for i in ag_nodes]
	while selection in agent_nodes:
		selection = random.choice(nodes)
	if selection in [i for i in node_mappings]:
		value = node_mappings[selection]
		map_entry = [i for i in ag_nodes]
		map_entry.append((selection,value))
	else:
		state = np.linspace(0,1,11)
		value = random.choice(state)
		map_entry = [i for i in ag_nodes]
		map_entry.append((selection,value))
	return map_entry

def modification(nodes,links):
	node_list = list(set(list(chain(*nodes))))
	possibilities = list(permutations(node_list,2))
	choices = list(set(possibilities) - set(links))
	if len(choices) == 0:
		node_links = links
	else:
		node_choice = random.sample(choices,k=1)
		node_links = links + node_choice
	return node_links

def transmission(agents,agent,mapps,edgee):
	list_of_agents = [i for i in agents if i!=agent]
	sender = np.random.choice(list_of_agents,1)
	sender = sender[0]
	sender_node_value = list(mapps[sender])
	sender_edge_value = list(edgee[sender])
	observation = nx.DiGraph()
	for node in sender_node_value:
		observation.add_node(node[0],state=node[1])
	dic_state = nx.get_node_attributes(observation,'state')
	for ed1,ed2 in sender_edge_value:
		weighting = (dic_state[ed1] + dic_state[ed2]) / 2
		rounded = int(round(weighting))
		observation.add_edge(ed1,ed2, weight = rounded)

	inference = nx.DiGraph()
	source_value = sender_edge_value[0][0]
	compressor = nx.shortest_path(observation,source=source_value,weight=None,method='dijkstra')
	for com in compressor:
		inference.add_node(com,state=dic_state[com])
		paths = compressor[com]
		if len(paths) > 1:
			nx.add_path(inference,paths)
	dic_states = nx.get_node_attributes(inference,'state')
	ls_states = [(i,dic_states[i]) for i in dic_states]
	ed = nx.edges(inference)
	return ls_states, list(ed)

def inheritance(agent,mapps,edgee):
	sender = agent
	sender_node_value = list(mapps[sender])
	sender_edge_value = list(edgee[sender])
	observation = nx.DiGraph()
	for node in sender_node_value:
		observation.add_node(node[0],state=node[1])
	dic_state =  nx.get_node_attributes(observation,'state')
	ls_state = dic_state
	ls_edge = sender_edge_value
	for ed1,ed2 in ls_edge:
		weighting = (dic_state[ed1] + dic_state[ed2]) / 2
		rounded = int(round(weighting))
		observation.add_edge(ed1,ed2, weight = rounded)

	inference = nx.DiGraph()
	source_value = sender_edge_value[0][0]
	compressor = nx.shortest_path(observation,source=source_value,weight=None,method='dijkstra')
	for com in compressor:
		inference.add_node(com,state=dic_state[com])
		paths = compressor[com]
		if len(paths) > 1:
			nx.add_path(inference,paths)
	dic_states = nx.get_node_attributes(inference,'state')
	ls_states = [(i,dic_states[i]) for i in dic_states]
	ed = nx.edges(inference)
	return ls_states,list(ed)